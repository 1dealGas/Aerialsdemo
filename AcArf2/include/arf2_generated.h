// Source: Arf2.fbs
// Please conform to the License of FlatBuffers(Apache 2.0 License).
using namespace std;


// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_ARF2_H_
#define FLATBUFFERS_GENERATED_ARF2_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
							FLATBUFFERS_VERSION_MINOR == 5 &&
							FLATBUFFERS_VERSION_REVISION == 26,
						 "Non-compatible flatbuffers version included");

struct WishChild;
struct WishChildBuilder;

struct WishGroup;
struct WishGroupBuilder;

struct Arf2Index;
struct Arf2IndexBuilder;

struct Arf2;
struct Arf2Builder;

struct WishChild FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
	typedef WishChildBuilder Builder;
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_P = 4,
		VT_DT = 6,
		VT_ANODES = 8
	};
	uint8_t p() const {
		return GetField<uint8_t>(VT_P, 255);
	}
	bool mutate_p(uint8_t _p = 255) {
		return SetField<uint8_t>(VT_P, _p, 255);
	}
	uint32_t dt() const {
		return GetField<uint32_t>(VT_DT, 0);
	}
	bool mutate_dt(uint32_t _dt = 0) {
		return SetField<uint32_t>(VT_DT, _dt, 0);
	}
	const ::flatbuffers::Vector<uint32_t> *anodes() const {
		return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ANODES);
	}
	::flatbuffers::Vector<uint32_t> *mutable_anodes() {
		return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_ANODES);
	}
	bool Verify(::flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
					 VerifyField<uint8_t>(verifier, VT_P, 1) &&
					 VerifyField<uint32_t>(verifier, VT_DT, 4) &&
					 VerifyOffset(verifier, VT_ANODES) &&
					 verifier.VerifyVector(anodes()) &&
					 verifier.EndTable();
	}
};

struct WishChildBuilder {
	typedef WishChild Table;
	::flatbuffers::FlatBufferBuilder &fbb_;
	::flatbuffers::uoffset_t start_;
	void add_p(uint8_t p) {
		fbb_.AddElement<uint8_t>(WishChild::VT_P, p, 255);
	}
	void add_dt(uint32_t dt) {
		fbb_.AddElement<uint32_t>(WishChild::VT_DT, dt, 0);
	}
	void add_anodes(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> anodes) {
		fbb_.AddOffset(WishChild::VT_ANODES, anodes);
	}
	explicit WishChildBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	::flatbuffers::Offset<WishChild> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = ::flatbuffers::Offset<WishChild>(end);
		return o;
	}
};

inline ::flatbuffers::Offset<WishChild> CreateWishChild(
		::flatbuffers::FlatBufferBuilder &_fbb,
		uint8_t p = 255,
		uint32_t dt = 0,
		::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> anodes = 0) {
	WishChildBuilder builder_(_fbb);
	builder_.add_anodes(anodes);
	builder_.add_dt(dt);
	builder_.add_p(p);
	return builder_.Finish();
}

struct WishGroup FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
	typedef WishGroupBuilder Builder;
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_INFO = 4,
		VT_NODES = 6,
		VT_CHILDS = 8
	};
	uint32_t info() const {
		return GetField<uint32_t>(VT_INFO, 4294967295);
	}
	bool mutate_info(uint32_t _info = 4294967295) {
		return SetField<uint32_t>(VT_INFO, _info, 4294967295);
	}
	const ::flatbuffers::Vector<uint64_t> *nodes() const {
		return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_NODES);
	}
	::flatbuffers::Vector<uint64_t> *mutable_nodes() {
		return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_NODES);
	}
	const ::flatbuffers::Vector<::flatbuffers::Offset<WishChild>> *childs() const {
		return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<WishChild>> *>(VT_CHILDS);
	}
	::flatbuffers::Vector<::flatbuffers::Offset<WishChild>> *mutable_childs() {
		return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<WishChild>> *>(VT_CHILDS);
	}
	bool Verify(::flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
					 VerifyField<uint32_t>(verifier, VT_INFO, 4) &&
					 VerifyOffset(verifier, VT_NODES) &&
					 verifier.VerifyVector(nodes()) &&
					 VerifyOffset(verifier, VT_CHILDS) &&
					 verifier.VerifyVector(childs()) &&
					 verifier.VerifyVectorOfTables(childs()) &&
					 verifier.EndTable();
	}
};

struct WishGroupBuilder {
	typedef WishGroup Table;
	::flatbuffers::FlatBufferBuilder &fbb_;
	::flatbuffers::uoffset_t start_;
	void add_info(uint32_t info) {
		fbb_.AddElement<uint32_t>(WishGroup::VT_INFO, info, 4294967295);
	}
	void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> nodes) {
		fbb_.AddOffset(WishGroup::VT_NODES, nodes);
	}
	void add_childs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<WishChild>>> childs) {
		fbb_.AddOffset(WishGroup::VT_CHILDS, childs);
	}
	explicit WishGroupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	::flatbuffers::Offset<WishGroup> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = ::flatbuffers::Offset<WishGroup>(end);
		return o;
	}
};

inline ::flatbuffers::Offset<WishGroup> CreateWishGroup(
		::flatbuffers::FlatBufferBuilder &_fbb,
		uint32_t info = 4294967295,
		::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> nodes = 0,
		::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<WishChild>>> childs = 0) {
	WishGroupBuilder builder_(_fbb);
	builder_.add_childs(childs);
	builder_.add_nodes(nodes);
	builder_.add_info(info);
	return builder_.Finish();
}

struct Arf2Index FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
	typedef Arf2IndexBuilder Builder;
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_WIDX = 4,
		VT_HIDX = 6
	};
	const ::flatbuffers::Vector<uint16_t> *widx() const {
		return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_WIDX);
	}
	::flatbuffers::Vector<uint16_t> *mutable_widx() {
		return GetPointer<::flatbuffers::Vector<uint16_t> *>(VT_WIDX);
	}
	const ::flatbuffers::Vector<uint16_t> *hidx() const {
		return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_HIDX);
	}
	::flatbuffers::Vector<uint16_t> *mutable_hidx() {
		return GetPointer<::flatbuffers::Vector<uint16_t> *>(VT_HIDX);
	}
	bool Verify(::flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
					 VerifyOffset(verifier, VT_WIDX) &&
					 verifier.VerifyVector(widx()) &&
					 VerifyOffset(verifier, VT_HIDX) &&
					 verifier.VerifyVector(hidx()) &&
					 verifier.EndTable();
	}
};

struct Arf2IndexBuilder {
	typedef Arf2Index Table;
	::flatbuffers::FlatBufferBuilder &fbb_;
	::flatbuffers::uoffset_t start_;
	void add_widx(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> widx) {
		fbb_.AddOffset(Arf2Index::VT_WIDX, widx);
	}
	void add_hidx(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> hidx) {
		fbb_.AddOffset(Arf2Index::VT_HIDX, hidx);
	}
	explicit Arf2IndexBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	::flatbuffers::Offset<Arf2Index> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = ::flatbuffers::Offset<Arf2Index>(end);
		return o;
	}
};

inline ::flatbuffers::Offset<Arf2Index> CreateArf2Index(
		::flatbuffers::FlatBufferBuilder &_fbb,
		::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> widx = 0,
		::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> hidx = 0) {
	Arf2IndexBuilder builder_(_fbb);
	builder_.add_hidx(hidx);
	builder_.add_widx(widx);
	return builder_.Finish();
}

struct Arf2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
	typedef Arf2Builder Builder;
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_BEFORE = 4,
		VT_DTS_LAYER1 = 6,
		VT_DTS_LAYER2 = 8,
		VT_INDEX = 10,
		VT_WISH = 12,
		VT_WGO_REQUIRED = 14,
		VT_HINT = 16,
		VT_HGO_REQUIRED = 18,
		VT_SPECIAL_HINT = 20
	};
	uint32_t before() const {
		return GetField<uint32_t>(VT_BEFORE, 0);
	}
	bool mutate_before(uint32_t _before = 0) {
		return SetField<uint32_t>(VT_BEFORE, _before, 0);
	}
	const ::flatbuffers::Vector<uint64_t> *dts_layer1() const {
		return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_DTS_LAYER1);
	}
	::flatbuffers::Vector<uint64_t> *mutable_dts_layer1() {
		return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_DTS_LAYER1);
	}
	const ::flatbuffers::Vector<uint64_t> *dts_layer2() const {
		return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_DTS_LAYER2);
	}
	::flatbuffers::Vector<uint64_t> *mutable_dts_layer2() {
		return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_DTS_LAYER2);
	}
	const ::flatbuffers::Vector<::flatbuffers::Offset<Arf2Index>> *index() const {
		return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Arf2Index>> *>(VT_INDEX);
	}
	::flatbuffers::Vector<::flatbuffers::Offset<Arf2Index>> *mutable_index() {
		return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Arf2Index>> *>(VT_INDEX);
	}
	const ::flatbuffers::Vector<::flatbuffers::Offset<WishGroup>> *wish() const {
		return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<WishGroup>> *>(VT_WISH);
	}
	::flatbuffers::Vector<::flatbuffers::Offset<WishGroup>> *mutable_wish() {
		return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<WishGroup>> *>(VT_WISH);
	}
	uint8_t wgo_required() const {
		return GetField<uint8_t>(VT_WGO_REQUIRED, 0);
	}
	bool mutate_wgo_required(uint8_t _wgo_required = 0) {
		return SetField<uint8_t>(VT_WGO_REQUIRED, _wgo_required, 0);
	}
	const ::flatbuffers::Vector<uint64_t> *hint() const {
		return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_HINT);
	}
	::flatbuffers::Vector<uint64_t> *mutable_hint() {
		return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_HINT);
	}
	uint8_t hgo_required() const {
		return GetField<uint8_t>(VT_HGO_REQUIRED, 0);
	}
	bool mutate_hgo_required(uint8_t _hgo_required = 0) {
		return SetField<uint8_t>(VT_HGO_REQUIRED, _hgo_required, 0);
	}
	uint16_t special_hint() const {
		return GetField<uint16_t>(VT_SPECIAL_HINT, 0);
	}
	bool mutate_special_hint(uint16_t _special_hint = 0) {
		return SetField<uint16_t>(VT_SPECIAL_HINT, _special_hint, 0);
	}
	bool Verify(::flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) &&
					 VerifyField<uint32_t>(verifier, VT_BEFORE, 4) &&
					 VerifyOffset(verifier, VT_DTS_LAYER1) &&
					 verifier.VerifyVector(dts_layer1()) &&
					 VerifyOffset(verifier, VT_DTS_LAYER2) &&
					 verifier.VerifyVector(dts_layer2()) &&
					 VerifyOffset(verifier, VT_INDEX) &&
					 verifier.VerifyVector(index()) &&
					 verifier.VerifyVectorOfTables(index()) &&
					 VerifyOffset(verifier, VT_WISH) &&
					 verifier.VerifyVector(wish()) &&
					 verifier.VerifyVectorOfTables(wish()) &&
					 VerifyField<uint8_t>(verifier, VT_WGO_REQUIRED, 1) &&
					 VerifyOffset(verifier, VT_HINT) &&
					 verifier.VerifyVector(hint()) &&
					 VerifyField<uint8_t>(verifier, VT_HGO_REQUIRED, 1) &&
					 VerifyField<uint16_t>(verifier, VT_SPECIAL_HINT, 2) &&
					 verifier.EndTable();
	}
};

struct Arf2Builder {
	typedef Arf2 Table;
	::flatbuffers::FlatBufferBuilder &fbb_;
	::flatbuffers::uoffset_t start_;
	void add_before(uint32_t before) {
		fbb_.AddElement<uint32_t>(Arf2::VT_BEFORE, before, 0);
	}
	void add_dts_layer1(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> dts_layer1) {
		fbb_.AddOffset(Arf2::VT_DTS_LAYER1, dts_layer1);
	}
	void add_dts_layer2(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> dts_layer2) {
		fbb_.AddOffset(Arf2::VT_DTS_LAYER2, dts_layer2);
	}
	void add_index(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Arf2Index>>> index) {
		fbb_.AddOffset(Arf2::VT_INDEX, index);
	}
	void add_wish(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<WishGroup>>> wish) {
		fbb_.AddOffset(Arf2::VT_WISH, wish);
	}
	void add_wgo_required(uint8_t wgo_required) {
		fbb_.AddElement<uint8_t>(Arf2::VT_WGO_REQUIRED, wgo_required, 0);
	}
	void add_hint(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> hint) {
		fbb_.AddOffset(Arf2::VT_HINT, hint);
	}
	void add_hgo_required(uint8_t hgo_required) {
		fbb_.AddElement<uint8_t>(Arf2::VT_HGO_REQUIRED, hgo_required, 0);
	}
	void add_special_hint(uint16_t special_hint) {
		fbb_.AddElement<uint16_t>(Arf2::VT_SPECIAL_HINT, special_hint, 0);
	}
	explicit Arf2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
				: fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	::flatbuffers::Offset<Arf2> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o = ::flatbuffers::Offset<Arf2>(end);
		return o;
	}
};

inline ::flatbuffers::Offset<Arf2> CreateArf2(
		::flatbuffers::FlatBufferBuilder &_fbb,
		uint32_t before = 0,
		::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> dts_layer1 = 0,
		::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> dts_layer2 = 0,
		::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Arf2Index>>> index = 0,
		::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<WishGroup>>> wish = 0,
		uint8_t wgo_required = 0,
		::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> hint = 0,
		uint8_t hgo_required = 0,
		uint16_t special_hint = 0) {
	Arf2Builder builder_(_fbb);
	builder_.add_hint(hint);
	builder_.add_wish(wish);
	builder_.add_index(index);
	builder_.add_dts_layer2(dts_layer2);
	builder_.add_dts_layer1(dts_layer1);
	builder_.add_before(before);
	builder_.add_special_hint(special_hint);
	builder_.add_hgo_required(hgo_required);
	builder_.add_wgo_required(wgo_required);
	return builder_.Finish();
}

inline const Arf2 *GetArf2(const void *buf) {
	return ::flatbuffers::GetRoot<Arf2>(buf);
}

inline const Arf2 *GetSizePrefixedArf2(const void *buf) {
	return ::flatbuffers::GetSizePrefixedRoot<Arf2>(buf);
}

inline Arf2 *GetMutableArf2(void *buf) {
	return ::flatbuffers::GetMutableRoot<Arf2>(buf);
}

inline Arf2 *GetMutableSizePrefixedArf2(void *buf) {
	return ::flatbuffers::GetMutableSizePrefixedRoot<Arf2>(buf);
}

inline bool VerifyArf2Buffer(
		::flatbuffers::Verifier &verifier) {
	return verifier.VerifyBuffer<Arf2>(nullptr);
}

inline bool VerifySizePrefixedArf2Buffer(
		::flatbuffers::Verifier &verifier) {
	return verifier.VerifySizePrefixedBuffer<Arf2>(nullptr);
}

inline void FinishArf2Buffer(
		::flatbuffers::FlatBufferBuilder &fbb,
		::flatbuffers::Offset<Arf2> root) {
	fbb.Finish(root);
}

inline void FinishSizePrefixedArf2Buffer(
		::flatbuffers::FlatBufferBuilder &fbb,
		::flatbuffers::Offset<Arf2> root) {
	fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_ARF2_H_