--------------------------------------------------------------------------------------
--  Aerials Initial Part
--     As the 1st Lua Script to be loaded,
--     We document and prepare some global variables used in Aerials here.
--  Copyright (c) 2024- 1dealGas, under the MIT License.
--------------------------------------------------------------------------------------

-- Interlude
--                               -- Order of interlude calls:
InterludeCallbackIn = nil        -- InterludeIn -> InterludeCallbackIn
InterludeCallbackOut = nil       --             -> InterludeOut -> InterludeCallbackOut


-- Input & GUI System
--
-- Rule 1:
--    Phase 0 / Pressed
--    Phase 1 / OnScreen
--    Phase 2 / Released
--
-- Rule 2:
--    When adding a GUI Node, cache its index and update NodeMaxIndex,
--    and then increase the NodeCount, like this:
--        NodeMaxIndex = NodeMaxIndex + 1
--        local insert_index	= NodeMaxIndex
--        Nodes[insert_index]	= msg.url()
--        NodeCount = NodeCount + 1
--
-- Rule 3:
--    Remove a GUI Node like this:
--        Nodes[insert_index] = nil
--        NodeCount = NodeCount - 1
--    Then it's ok to do other clean-ups.
--
WindowActive = true
WithinInterlude = true
LayoutModeLandscape = false

NodeMaxIndex = 0
NodeCount = 0
Nodes = {}

CurrentGuiX = 0
CurrentGuiY = 0
CurrentGuiPhase = nil
-- There is also a GuiDoFeedback() function.


-- Track Managing & Resources Related
--
Tracks = {}
CurrentTrackId = 1011
CurrentTrackIndex = 0            -- Unused in the Demo

CurrentAudioRes = nil
CurrentAudioUnit = nil
CurrentAudioBuffer = nil

CurrentPlate = nil               -- Unused in the Demo
CurrentFumenScript = nil         -- Unused in the Demo


-- Fumen Context & Scoring
--
ContextTime = nil                -- msTime or nil
WishSprites = nil                -- No need to expose other context info here
Hit, Early, Late = 0, 0, 0
TotalJud = 0


-- User Options
--
OffsetType = 1
AudioLatency, InputDelta = 0, 0
HapticFeedbackEnabled = true
HitSoundEnabled = false           -- Unused in the Demo


-- FumenScript
--
-- Rule 1:
--    Manually Register the Fumen Script in Engine init(self) like this:
--        CurrentFumenScript = msg.url("#")
--
-- Rule 2:
--    Provide the TriggerFns table like this, or nil:
--        {
--            10000, function() end,   -- TriggerMs, TriggerFn
--            20000, function() end
--        }
--
-- Rule 3:
--    Provide TaskFns table like this, or nil:
--        {
--            10000, 18000, function() end,   -- StartMs, EndMs, TaskFn
--            12000, 24000, function() end
--        }
--
function DeclareFumenScript(FmInitFn, FmFinalFn, TriggerFns, TaskFns, SpecialHintJudgedFn)
	local type, nt = type, Arf2.NewTable
	local table_sort, time_sorter = table.sort, function(a,b) return a[1]<b[1] end

	TriggerFns = type(TriggerFns)=="table" and TriggerFns or {}
	TaskFns = type(TaskFns)=="table" and TaskFns or {}
	local trigger_count, task_count = #TriggerFns/2, #TaskFns/3

	-- Sort Triggers
	--
	local cnt = 1
	local trigger_tables = nt(trigger_count, 0)
	for i=1, #TriggerFns, 2 do
		trigger_tables[cnt] = { TriggerFns[i], TriggerFns[i+1] }      -- TriggerMs, TriggerFn
		cnt = cnt + 1
	end
	table_sort(trigger_tables, time_sorter)

	-- Lump Tasks
	--
	local cnt = 1
	local task_tables = nt(task_count, 0)
	for i=1, #TaskFns, 3 do
		task_tables[cnt] = { TaskFns[i], TaskFns[i+1], TaskFns[i+2] }   -- StartMs, EndMs, TaskFn
		cnt = cnt + 1
	end
	table_sort(task_tables, time_sorter)   -- Sort by StartMs

	-- Create Registers & Unregisters
	--
	local register_tables, unregister_tables = nt(task_count, 0), nt(task_count, 0)
	for i=1, task_count do
		register_tables[i] = {task_tables[i][1], task_tables[i][3]}   -- StartMs, TaskFn
		unregister_tables[i] = {task_tables[i][2], i}   -- EndMs, UnregisterWhich
	end
	table_sort(unregister_tables, time_sorter)   -- register_tables sorted

	-- Expand Stuff
	--
	local Trigger = nt(trigger_count*2, 0)   -- Alternative TriggerMs, TriggerFn
	local Register = nt(task_count*2, 0)   -- Alternative StartMs, RegisterFn
	local Unregister = nt(task_count*2, 0)   -- Alternative EndMs, UnregisterWhich

	for i=1, trigger_count do
		Trigger[i*2-1] = trigger_tables[i][1]
		Trigger[i*2] = trigger_tables[i][2]
	end
	for i=1, task_count do
		Register[i*2-1] = register_tables[i][1]
		Register[i*2] = register_tables[i][2]
		Unregister[i*2-1] = unregister_tables[i][1]
		Unregister[i*2] = unregister_tables[i][2]
	end

	TriggerFns, TaskFns = nil, nil
	trigger_tables, task_tables = nil, nil
	register_tables, unregister_tables = nil, nil

	-- Do "Macro-Like" Stuff
	--
	do
		local Tasks, TaskCount, TaskMaxIndex = {}, 0, 0
		local TriggerWhich, RegisterWhich, UnregisterWhich = 1, 1, 1

		local MSG_FUNCS = {
			[hash("ar_init")] = type(FmInitFn)=="function" and FmInitFn or nil,
			[hash("ar_final")] = type(FmFinalFn)=="function" and FmFinalFn or nil,
			[hash("ar_special_hint_judged")] = type(SpecialHintJudgedFn)=="function" and SpecialHintJudgedFn or nil,
			[hash("ar_update")] = function()   -- Will be called only when ContextTime exists
					-- Trigger
					--
					local current_trigger_time = Trigger[TriggerWhich]
					if current_trigger_time and ContextTime > current_trigger_time then
						Trigger[TriggerWhich+1]()
						TriggerWhich = TriggerWhich + 2
					end

					-- Register
					--
					local current_register_time = Register[RegisterWhich]
					if current_register_time and ContextTime > current_register_time then
						TaskMaxIndex = TaskMaxIndex + 1
						Tasks[TaskMaxIndex] = Register[RegisterWhich+1]
						RegisterWhich = RegisterWhich + 2
						TaskCount = TaskCount + 1
					end

					-- Unregister
					--
					local current_unregister_time = Unregister[UnregisterWhich]
					if current_unregister_time and ContextTime > current_unregister_time then
						Tasks[ Unregister[UnregisterWhich+1] ] = nil
						UnregisterWhich = UnregisterWhich + 2
						TaskCount = TaskCount - 1
						if TaskCount == 0 then
							TaskMaxIndex = 0
						end
					end

					-- Do Tasks
					--
					for i=1, TaskMaxIndex do
						if Tasks[i] then
							Tasks[i]()
						end
					end
			end
		}

		function on_message(self, message_id)
			if MSG_FUNCS[message_id] then
				MSG_FUNCS[message_id]()
			end
		end
	end

	collectgarbage()
end


-- Save & Credits
-- Save == nil before the initialization
--
local B64 = require("Reference/lbase64")
local SAVE_PATH = sys.get_save_file("Aerials Demo", "SAVE")
local EMPTY_SAVE = {
	Aerials = "Save",  Wish = 0,  Hint = {},  Challenges = {},
	Options = {
		OffsetType = 1, 
		AudioLatency1 = 0,
		AudioLatency2 = 0,
		AudioLatency3 = 0,
		InputDelta = 0,
		HapticFeedbackEnabled = true,
		HitSoundEnabled = false
	}
}

function CopyCredit() clipboard.copy( sys.load_resource("/Ar.license") ) end
function ExportSave() clipboard.copy( B64.encode( sys.serialize(Save) ) ) end
function ImportSave()
	local OK, SaveStr = pcall( B64.decode, clipboard.paste() )
	local OK, SaveTable = pcall(sys.deserialize, SaveStr)

	if OK and SaveTable.Aerials and SaveTable.Aerials=="Save" then
		ExportSave()
		Save = SaveTable

		OffsetType = Save.Options.OffsetType
		AudioLatency = (OffsetType==1 and Save.Options.AudioLatency1) or (OffsetType==2 and Save.Options.AudioLatency2) or Save.Options.AudioLatency3
		HapticFeedbackEnabled, HitSoundEnabled = Save.Options.HapticFeedbackEnabled, Save.Options.HitSoundEnabled

		InputDelta = Save.Options.InputDelta
		Arf2.SetIDelta(InputDelta)
		return true
	else
		return false
	end
end

function SyncSave(options_updated)
	if options_updated then
		Save.Options.OffsetType = OffsetType
		Save.Options.InputDelta = InputDelta
		Save.Options.HitSoundEnabled = HitSoundEnabled
		Save.Options.HapticFeedbackEnabled = HapticFeedbackEnabled

		if OffsetType == 1 then
			Save.Options.AudioLatency1 = AudioLatency
		elseif OffsetType == 2 then
			Save.Options.AudioLatency2 = AudioLatency
		else
			Save.Options.AudioLatency3 = AudioLatency
		end
	end

	sys.save(SAVE_PATH, Save)
end


-- Initialization
--
do
	Save = sys.load(SAVE_PATH)
	if not Save.Aerials then
		Save = sys.deserialize( sys.serialize(EMPTY_SAVE) )   -- Copy the empty save
		sys.save(SAVE_PATH, Save)
	end

	OffsetType = Save.Options.OffsetType
	AudioLatency = (OffsetType==1 and Save.Options.AudioLatency1) or (OffsetType==2 and Save.Options.AudioLatency2) or Save.Options.AudioLatency3
	HapticFeedbackEnabled = Save.Options.HapticFeedbackEnabled
	HitSoundEnabled = Save.Options.HitSoundEnabled

	InputDelta = Save.Options.InputDelta
	Arf2.SetIDelta(InputDelta)
end


--------------------------------    Render Script    --------------------------------
--
-- Copyright 2020-2024 The Defold Foundation
-- Copyright 2014-2020 King
-- Copyright 2009-2014 Ragnar Svensson, Christian Murray
-- Licensed under the Defold License version 1.0 (the "License"); you may not use
-- this file except in compliance with the License.
-- 
-- You may obtain a copy of the License, together with FAQs at
-- https://www.defold.com/license
-- 
-- Unless required by applicable law or agreed to in writing, software distributed
-- under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
-- CONDITIONS OF ANY KIND, either express or implied. See the License for the
-- specific language governing permissions and limitations under the License.
--
--
-- Modified by 1dealGas:
--     Only Use "Fixed Fit" & "GUI" Projections (Cameras are Banned)
--     Convert indentations to Tabs
--     Cache API Functions & Enums
--     Strip Several Encapsulations We Considered Useless
--
--
local hash = hash
local pairs = pairs
local vmath_vector4 = vmath.vector4
local vmath_matrix4 = vmath.matrix4
local vmath_matrix4_orthographic = vmath.matrix4_orthographic
local sys_get_config_number = sys.get_config_number
local render_predicate = render.predicate
local render_get_window_width = render.get_window_width
local render_get_window_height = render.get_window_height
local render_get_width = render.get_width
local render_get_height = render.get_height
local render_set_depth_mask = render.set_depth_mask
local render_set_stencil_mask = render.set_stencil_mask
local render_clear = render.clear
local render_set_viewport = render.set_viewport
local render_set_view = render.set_view
local render_set_projection = render.set_projection
local render_set_blend_func = render.set_blend_func
local render_enable_state = render.enable_state
local render_disable_state = render.disable_state
local render_draw_debug3d = render.draw_debug3d
local render_draw = render.draw

--
-- Constants
--
local MSG_CLEAR_COLOR =         hash("clear_color")
local MSG_WINDOW_RESIZED =      hash("window_resized")
local render_BUFFER_COLOR_BIT = render.BUFFER_COLOR_BIT
local render_BUFFER_DEPTH_BIT = render.BUFFER_DEPTH_BIT
local render_BUFFER_STENCIL_BIT = render.BUFFER_STENCIL_BIT
local render_BLEND_SRC_ALPHA = render.BLEND_SRC_ALPHA
local render_BLEND_ONE_MINUS_SRC_ALPHA = render.BLEND_ONE_MINUS_SRC_ALPHA
local render_STATE_DEPTH_TEST = render.STATE_DEPTH_TEST
local render_STATE_CULL_FACE = render.STATE_CULL_FACE
local render_STATE_BLEND = render.STATE_BLEND
local render_STATE_STENCIL_TEST = render.STATE_STENCIL_TEST

--
-- Unwraped State & Camera Args
-- Near = -1, Far = 1, Zoom = 1
--
local state_clear_buffers = {}
local p_tile, p_gui, p_text, p_particle, p_model

local state_window_w = 0
local state_window_h = 0
local state_window_w_prev = 0
local state_window_h_prev = 0
local state_width = 0
local state_height = 0

local cw_frustum, cg_frustum = {}, {}
local cw_view, cg_view = vmath_matrix4(), vmath_matrix4()
local cw_proj, cg_proj

state_clear_buffers[render_BUFFER_COLOR_BIT] = vmath_vector4(0, 0, 0, 0)
state_clear_buffers[render_BUFFER_DEPTH_BIT] = 1
state_clear_buffers[render_BUFFER_STENCIL_BIT] = 0


--
-- Last Encapsulation Layer
--
local function update_state(w, h)
	state_window_w = w or render_get_window_width()
	state_window_h = h or render_get_window_height()
	if not (state_window_w > 0 and state_window_h > 0) then
		return false
	end
	if state_window_w == state_window_w_prev and state_window_h == state_window_h_prev then
		return true
	end
	state_window_w_prev = state_window_w
	state_window_h_prev = state_window_h
	state_width = render_get_width()
	state_height = render_get_height()

	-- World Camera: Fixed Fit
	local wr = state_window_w / state_width
	local hr = state_window_h / state_height

	local projected_width, projected_height
	if wr >= hr then
		projected_width = state_window_w / hr
		projected_height = state_window_h / hr
	else
		projected_width = state_window_w / wr
		projected_height = state_window_h / wr
	end

	local left = (state_width - projected_width) / 2
	local bottom = (state_height - projected_height) / 2

	cw_proj = vmath_matrix4_orthographic(left, left + projected_width, bottom, bottom + projected_height, -1, 1)
	cw_frustum.frustum = cw_proj * cw_view

	-- GUI Camera
	cg_proj = vmath_matrix4_orthographic(0, state_window_w, 0, state_window_h, -1, 1)
	cg_frustum.frustum = cg_proj * cg_view

	return true
end


--
-- Defold Gameloop Funcs
--
function init(self)
	-- You can only access render.* functions and values from a render script instance (.render_script file)
	p_tile = render_predicate( {"tile"} )
	p_gui = render_predicate( {"gui"} )
	p_text = render_predicate( {"text"} )
	p_particle = render_predicate( {"particle"} )
	p_model = render_predicate( {"model"} )
	update_state()
end

function update(self)

	-- Check if the state is valid
	--
	if not (state_window_w > 0 and state_window_h > 0) then
		if not update_state() then
			return
		end
	end

	-- Clear screen buffers
	--
	render_set_depth_mask(true)   -- turn on depth_mask before `render.clear()` to clear it as well
	render_set_stencil_mask(0xff)
	render_clear(state_clear_buffers)

	-- Setup camera view and projection
	--
	render_set_viewport(0, 0, state_window_w, state_window_h)
	render_set_view(cw_view)
	render_set_projection(cw_proj)

	-- Set states used for all the world predicates
	render_set_blend_func(render_BLEND_SRC_ALPHA, render_BLEND_ONE_MINUS_SRC_ALPHA)
	render_enable_state(render_STATE_DEPTH_TEST)

	-- Render `model` predicate for default 3D material
	--
	render_enable_state(render_STATE_CULL_FACE)
	render_draw(p_model, cw_frustum)
	render_set_depth_mask(false)
	render_disable_state(render_STATE_CULL_FACE)

	-- Render the other components: sprites, tilemaps, particles etc
	--
	render_enable_state(render_STATE_BLEND)
	render_draw(p_tile, cw_frustum)   -- Sprites are using the "tile" tag
	render_draw(p_particle, cw_frustum)
	render_disable_state(render_STATE_DEPTH_TEST)
	render_draw_debug3d()

	-- Render GUI
	--
	render_set_view(cg_view)
	render_set_projection(cg_proj)

	render_enable_state(render_STATE_STENCIL_TEST)
	render_draw(p_gui, cg_frustum)
	render_draw(p_text, cg_frustum)
	render_disable_state(render_STATE_STENCIL_TEST)
	render_disable_state(render_STATE_BLEND)
end

function on_message(self, message_id, message)
	if message_id == MSG_CLEAR_COLOR then
		local color = message.color
		if color then state_clear_buffers[render_BUFFER_COLOR_BIT] = color end
	elseif message_id == MSG_WINDOW_RESIZED then
		update_state(message.width, message.height)
	end
end